#include "GobanPatternManager.hsp"
#include "開発完了/sgf.hsp"
#include "namespace_base.hsp" //ハッシュ関連-> ( get_value, new_value, NOT_DEFINED_HASH)
#module
#defcfunc search str SGF_list, array pattern, array result, int max_depth, int colorflip



	stone_num = get_pattern_all_stones_num(pattern) //パターン内の全ての石数を取得
	if stone_num == 0: return 0

	sdim result,,2
	rn = 0

	最大の深さ = 50
	if max_depth{
		最大の深さ = max_depth
	}
	
	prexy = -1,-1
	
	//logmes "探索を開始します-> 石数 = " + stone_num
	dim valid, 1 + colorflip, r_patterun_num
	notesel ss
	ss = SGF_list
	repeat notemax
		noteget sgf,cnt

		notesel f
		noteload sgf
		noteunsel

		if get_value(sgf) == NOT_DEFINED_HASH{
			topnode = load_sgf(f, -1)
			//logmes "load_sgf -> " + topnode 
			new_value sgf, str(topnode)
		}else{
			
			topnode = int(refstr)
			//logmes "hash -> " + topnode
		}

		get_board_size_from_SGF topnode, xy

		//前回検索した棋譜とボードサイズが違う場合
		if prexy != xy || prexy.1 != xy.1{
			//新たなパターンを生成
			make_rotated_patterns pattern, xy,xy.1 , rotated_p
			prexy = xy,xy.1
		}

		r_pattern_num = 4 << (xy == xy.1)
		all_pattern_num = r_pattern_num * (colorflip + 1) 
		
		if search_main(topnode, rotated_p, match_node, colorflip){
			result(0,rn) = sgf //一致したSGFを結果に追加
			result(1,rn) = str(match_node)
			rn++
		}
	loop
	noteunsel
	return rn

#defcfunc search_main int t, array pattern, var result_node, int colorflip

/*
 t:
 - 検索開始のノード番号
 pattern:
 - 検索に使うパターン
 result_node:
 -検索に一致した場合そのノード番号を返す

 return_value -> マッチしたかどうかの　1か0の値
*/

	

	//探索スタック初期化
	sn = 0
	repeat r_pattern_num
		for i,,1 + colorflip
			node_stack(sn) = t
			hit_count_stack(sn) = 0 
			r_pattern_stack(sn) = cnt
			c_pattern_stack(sn) = i
			depth_stack(sn) = 1 
			sn++
			valid(i,cnt) = 1
		next
	loop

	failed_count = 0

	while sn
		sn--

		//以下ノードを取り出して処理。
		depth = depth_stack(sn)

		if depth > 最大の深さ{
			_continue
		}
		
		node = node_stack(sn)
		hit_num = hit_count_stack(sn)
		r_p = r_pattern_stack(sn)
		c_p = c_pattern_stack(sn)


		if node != t{ //トップノード以外(トップノードは着手が存在しないため)

			turn = get_property_coordinate_cash(node, coordinate) //ノードの手番、座標を取得
	
			x = coordinate
			y = coordinate.1
	
			//パターン内の各矩形に対する処理
			for j,, length(pattern)
				split pattern(j,0,c_p,r_p),",", rect
				
				if in_rect(rect,x,y) == 0{
					_continue //矩形範囲外なので無視
				}

				//石情報を分離
				split pattern(j,1,c_p,r_p),"-", stones
	
				match_failed = 1 //見つからなかったら探索失敗とするフラグ
				
				//矩形に含まれる石数だけ繰り返す
				for i,,int(pattern(j,2,c_p,r_p))
				
					split stones(i), ":", tmp
					p_x = int(tmp)
					p_y = int(tmp.1)
					p_color = int(tmp.2)
					
					if (p_x == x) && (p_y == y){
						//マッチしたらhitカウント加算
						switch turn
						case 1 //黒石
							if p_color & PATTERN_BLACK{
								hit_num++
								match_failed = 0
							}
						swbreak
						case 2 //白石
							if p_color & PATTERN_WHITE{
								hit_num++
								match_failed = 0
							}
						swbreak
						swend
						_break
					}
				next
				if match_failed{
					valid(c_p, r_p) = 0
					failed_count++
					if failed_count == all_pattern_num{
						return 0
					}
					_break
				}
				if hit_num == stone_num{
					result_node = node //一致したSGFノード
					return 1 //検索成功
				}
				
			next
			if valid(c_p, r_p) = 0: _continue
		}
		
		
		repeat get_SGF_childs(node, child)
			node_stack(sn) = child(cnt)
			hit_count_stack(sn) = hit_num
			r_pattern_stack(sn) = r_p
			c_pattern_stack(sn) = c_p
			depth_stack(sn) = depth + 1
			sn++
		loop
		

	wend
	return 0

#defcfunc in_rect array a, int _x, int _y
	if int(a(0)) > _x: return 0
	if int(a(1)) > _y: return 0
	if int(a(2)) < _x: return 0
	if int(a(3)) < _y: return 0
	return 1
	
#global