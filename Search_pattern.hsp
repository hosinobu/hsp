#include "GobanPatternManager.hsp"
#include "開発完了/sgf.hsp"
#include "namespace_base.hsp" //ハッシュ関連-> ( get_value, new_value, NOT_DEFINED_HASH)
#module
#deffunc search str SGF_list, array pattern, array result

	sdim result,,2
	rn = 0

	stone_num = get_pattern_all_stones_num(pattern) //パターン内の全ての石数を取得
	if stone_num == 0: return 
	
	logmes "探索を開始します-> 石数 = " + stone_num

	notesel ss
	ss = SGF_list
	repeat notemax
		noteget sgf,cnt

		notesel f
		noteload sgf
		noteunsel

		if get_value(sgf) == NOT_DEFINED_HASH{
			topnode = load_sgf(f, -1)
			logmes "load_sgf -> " + topnode 
			new_value sgf, str(topnode)
		}else{
			
			topnode = int(refstr)
			logmes "hash -> " + topnode
		}
		
		if search_main(topnode, pattern, match_node){
			result(0,rn) = sgf //一致したSGFを結果に追加
			result(1,rn) = str(match_node)
			rn++
		}
	loop
	noteunsel
	return rn

#const 最大の深さ 50
#defcfunc search_main int t, array pattern, var result_node

	logmes "called_search_main"
	//探索スタック初期化
	node_stack = t //処理したいノード
	hit_count_stack = 0 //hitした石数を数える
	depth_stack = 1 //深さ
	sn = 1

	while sn
		sn--
		node = node_stack(sn)
		hit_num = hit_count_stack(sn)
		depth = depth_stack(sn)

		if node != t{ //トップノード以外(トップノードは着手が存在しないため)

		
			if depth > 最大の深さ{
				//手数が制限を超えたのでこのノードは探索打ち切り
				_continue
			}
	
			turn = get_property_coordinate(node, coordinate) //ノードの手番、座標を取得
	
			x = coordinate
			y = coordinate.1
	
			
			//パターン内の各矩形に対する処理
			for j,, length(pattern)
				split pattern(j,0),",", rect
				
				if in_rect(rect,x,y) == 0{
					_continue //矩形範囲外なので無視
				}

				//石情報を分離
				split pattern(j,1),";", stones
	
				match_failed = 1 //見つからなかったら探索失敗とするフラグ
				
				//矩形に含まれる石数だけ繰り返す
				for i,,int(pattern(j,2))
				
					split stones(i), ":", tmp
					p_x = int(tmp)
					p_y = int(tmp.1)
					p_color = int(tmp.2)
					
					if (p_x == x) && (p_y == y){
						//マッチしたらhitカウント加算
						switch turn
						case 1 //黒石
							if p_color & PATTERN_BLACK{
								hit_num++
								match_failed = 0
							}
						swbreak
						case 2 //白石
							if p_color & PATTERN_WHITE{
								hit_num++
								match_failed = 0
							}
						swbreak
						swend
						_break
					}
				next
				if match_failed{
					return 0
				}
				if hit_num == stone_num{
					result_node = node //一致したSGFノード
					return 1 //検索成功
				}
				
			next
		}
		repeat get_SGF_childs(node, child)
			node_stack(sn) = child(cnt)
			hit_count_stack(sn) = hit_num
			depth_stack(sn) = depth + 1
			sn++
		loop

	wend
	return 0

#defcfunc in_rect array a, int _x, int _y
	if int(a(0)) > _x: return 0
	if int(a(1)) > _y: return 0
	if int(a(2)) < _x: return 0
	if int(a(3)) < _y: return 0
	return 1
	
#global